// scanners/fuzzing/VulnerabilityDetector.java
package scanners.fuzzing;

import core.Vulnerability;
import java.util.*;
import java.util.regex.Pattern;

public class VulnerabilityDetector {

    private static final Set<String> SQL_ERRORS = Set.of(
            "sql", "mysql", "ora-", "microsoft ole db", "postgresql",
            "syntax error", "violation", "mysql_fetch", "pg_",
            "warning: mysql", "unclosed quotation", "odbc"
    );

    private static final Set<String> XSS_INDICATORS = Set.of(
            "script", "alert(", "onerror", "onload", "javascript:"
    );

    private static final Set<String> PATH_TRAVERSAL_INDICATORS = Set.of(
            "root:", "/etc/passwd", "windows/system32", "permission denied"
    );

    private static final Set<String> COMMAND_INJECTION_INDICATORS = Set.of(
            "bin/bash", "cmd.exe", "command not found", "syntax error"
    );

    public Vulnerability analyzeResponse(ApiEndpoint endpoint, ApiParameter parameter,
                                         String payload, HttpResponse response,
                                         long responseTime) {

        String responseBody = response.getBody().toLowerCase();
        int statusCode = response.getStatusCode();

        // Проверка SQL Injection
        if (detectSqlInjection(responseBody, statusCode, payload)) {
            return createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "SQL Injection in " + parameter.getName(),
                    "Обнаружена SQL инъекция через параметр " + parameter.getName() + " с payload: " + payload,
                    Vulnerability.Severity.HIGH,
                    Vulnerability.Category.SQL_INJECTION
            );
        }

        // Проверка XSS
        if (detectXss(responseBody, payload)) {
            return createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Cross-Site Scripting (XSS) in " + parameter.getName(),
                    "Обнаружена XSS уязвимость через параметр " + parameter.getName() + " с payload: " + payload,
                    Vulnerability.Severity.MEDIUM,
                    Vulnerability.Category.XSS
            );
        }

        // Проверка Path Traversal
        if (detectPathTraversal(responseBody, statusCode, payload)) {
            return createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Path Traversal in " + parameter.getName(),
                    "Обнаружена Path Traversal уязвимость через параметр " + parameter.getName() + " с payload: " + payload,
                    Vulnerability.Severity.HIGH,
                    Vulnerability.Category.PATH_TRAVERSAL
            );
        }

        // Проверка Command Injection
        if (detectCommandInjection(responseBody, statusCode, payload)) {
            return createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Command Injection in " + parameter.getName(),
                    "Обнаружена Command Injection уязвимость через параметр " + parameter.getName() + " с payload: " + payload,
                    Vulnerability.Severity.CRITICAL,
                    Vulnerability.Category.COMMAND_INJECTION
            );
        }

        // Проверка Time-based атак
        if (detectTimeBasedVulnerability(responseTime, payload)) {
            return createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Time-Based Blind Injection in " + parameter.getName(),
                    "Обнаружена возможная слепая уязвимость по времени ответа (" + responseTime + "ms) с payload: " + payload,
                    Vulnerability.Severity.MEDIUM,
                    Vulnerability.Category.SQL_INJECTION
            );
        }

        // Проверка Business Logic Bypass
        if (detectBusinessLogicBypass(statusCode, responseBody, payload)) {
            return createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Business Logic Bypass in " + parameter.getName(),
                    "Обнаружен возможный обход бизнес-логики через параметр " + parameter.getName() + " с payload: " + payload,
                    Vulnerability.Severity.MEDIUM,
                    Vulnerability.Category.BUSINESS_LOGIC_BYPASS
            );
        }

        // Проверка нестандартных кодов ответа
        if (detectSuspiciousStatusCode(statusCode)) {
            return createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Suspicious Response Code for " + parameter.getName(),
                    "Нестандартный код ответа " + statusCode + " при фаззинге параметра " + parameter.getName() + " с payload: " + payload,
                    Vulnerability.Severity.LOW,
                    Vulnerability.Category.FUZZING_GENERIC
            );
        }

        return null;
    }

    private boolean detectSqlInjection(String responseBody, int statusCode, String payload) {
        // Проверка ошибок SQL в теле ответа
        for (String error : SQL_ERRORS) {
            if (responseBody.contains(error)) {
                return true;
            }
        }

        // Проверка разницы в ответах при SQL-инъекциях
        if (statusCode == 500 && payload.contains("'")) {
            return true;
        }

        return false;
    }

    private boolean detectXss(String responseBody, String payload) {
        // Проверка отражения payload'а без экранирования
        String cleanPayload = payload.toLowerCase()
                .replace("<", "")
                .replace(">", "")
                .replace("\"", "")
                .replace("'", "");

        if (responseBody.contains(cleanPayload)) {
            for (String indicator : XSS_INDICATORS) {
                if (payload.toLowerCase().contains(indicator) && responseBody.contains(indicator)) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean detectPathTraversal(String responseBody, int statusCode, String payload) {
        if (!payload.contains("..") && !payload.contains("etc") && !payload.contains("windows")) {
            return false;
        }

        for (String indicator : PATH_TRAVERSAL_INDICATORS) {
            if (responseBody.contains(indicator)) {
                return true;
            }
        }

        return statusCode == 200 && payload.contains("..");
    }

    private boolean detectCommandInjection(String responseBody, int statusCode, String payload) {
        if (!payload.contains(";") && !payload.contains("|") && !payload.contains("&")) {
            return false;
        }

        for (String indicator : COMMAND_INJECTION_INDICATORS) {
            if (responseBody.contains(indicator)) {
                return true;
            }
        }

        return statusCode == 200 && (payload.contains(";") || payload.contains("|"));
    }

    private boolean detectTimeBasedVulnerability(long responseTime, String payload) {
        return responseTime > 5000 &&
                (payload.contains("sleep") || payload.contains("waitfor") || payload.contains("benchmark"));
    }

    private boolean detectBusinessLogicBypass(int statusCode, String responseBody, String payload) {
        // Отрицательные суммы, которые прошли
        if (payload.contains("-") && statusCode == 200) {
            return true;
        }

        // Очень большие числа, которые прошли
        if ((payload.contains("999999999") || payload.contains("1e308")) && statusCode == 200) {
            return true;
        }

        return false;
    }

    private boolean detectSuspiciousStatusCode(int statusCode) {
        return statusCode == 403 || statusCode == 500 || statusCode == 501;
    }

    private Vulnerability createVulnerability(ApiEndpoint endpoint, ApiParameter parameter,
                                              String payload, HttpResponse response,
                                              long responseTime, String title, String description,
                                              Vulnerability.Severity severity, Vulnerability.Category category) {

        Vulnerability vuln = new Vulnerability();
        vuln.setTitle(title);
        vuln.setDescription(description);
        vuln.setSeverity(severity);
        vuln.setCategory(category);
        vuln.setEndpoint(endpoint.getPath());
        vuln.setMethod(endpoint.getMethod().name());
        vuln.setParameter(parameter.getName());
        vuln.setStatusCode(response.getStatusCode());
        vuln.setResponseTime(responseTime);

        // Формирование доказательства
        String evidence = String.format(
                "Payload: %s\nStatus Code: %d\nResponse Time: %dms\nResponse Size: %d bytes",
                payload, response.getStatusCode(), responseTime, response.getBody().length()
        );
        vuln.setEvidence(evidence);

        // Добавление рекомендаций
        vuln.setRecommendations(generateRecommendations(category));

        return vuln;
    }

    private List<String> generateRecommendations(Vulnerability.Category category) {
        List<String> recommendations = new ArrayList<>();

        switch (category) {
            case SQL_INJECTION:
                recommendations.add("Используйте prepared statements и parameterized queries");
                recommendations.add("Валидируйте и санируйте все пользовательские входные данные");
                recommendations.add("Применяйте принцип наименьших привилегий для БД");
                recommendations.add("Используйте ORM с защитой от SQL инъекций");
                break;

            case XSS:
                recommendations.add("Экранируйте все пользовательские данные при выводе в HTML");
                recommendations.add("Используйте Content Security Policy (CSP)");
                recommendations.add("Установите заголовок X-XSS-Protection");
                recommendations.add("Валидируйте входные данные на стороне сервера");
                break;

            case PATH_TRAVERSAL:
                recommendations.add("Валидируйте пути к файлам с помощью whitelist");
                recommendations.add("Используйте базовые директории (chroot)");
                recommendations.add("Запретите использование специальных символов в путях");
                recommendations.add("Нормализуйте пути перед обработкой");
                break;

            case COMMAND_INJECTION:
                recommendations.add("Избегайте выполнения shell команд с пользовательскими данными");
                recommendations.add("Используйте whitelist разрешенных команд и параметров");
                recommendations.add("Экранируйте специальные символы в командах");
                recommendations.add("Используйте API вместо shell команд");
                break;

            case BUSINESS_LOGIC_BYPASS:
                recommendations.add("Реализуйте строгую валидацию бизнес-правил");
                recommendations.add("Проверяйте граничные значения для числовых параметров");
                recommendations.add("Внедрите лимиты и квоты для операций");
                recommendations.add("Логируйте подозрительные операции");
                break;

            default:
                recommendations.add("Проведите дополнительный анализ уязвимости");
                recommendations.add("Обновите зависимости и фреймворки");
                recommendations.add("Внедрите регулярное тестирование безопасности");
                recommendations.add("Рассмотрите использование WAF для дополнительной защиты");
        }

        return recommendations;
    }
}