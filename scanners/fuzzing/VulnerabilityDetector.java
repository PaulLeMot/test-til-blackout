package scanners.fuzzing;

import core.Vulnerability;
import core.Vulnerability.Category;
import core.Vulnerability.Severity;
import java.util.*;
import org.json.JSONObject;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class EnhancedVulnerabilityDetector {
    private static final Set<String> SSTI_INDICATORS = Set.of(
            "49", "error in expression", "freemarker", "thymeleaf",
            "velocity", "jinja", "template", "rendering error"
    );

    private static final Set<String> NOSQL_INDICATORS = Set.of(
            "syntax error", "$where", "invalid operator", "bson",
            "mongodb", "invalid query", "where clause"
    );

    private static final Set<String> CMD_INJECTION_INDICATORS = Set.of(
            "root:", "/bin/", "etc/passwd", "command not found",
            "permission denied", "syntax error near unexpected token"
    );

    private static final Pattern JSON_PATTERN = Pattern.compile("^\\{.*\\}$");
    private static final Pattern XML_PATTERN = Pattern.compile("^<.*>$");

    public Vulnerability detectInjection(ApiEndpoint endpoint, ApiParameter parameter,
                                         String payload, HttpResponse response,
                                         Category vulnerabilityType) {
        // Игнорируем ошибки валидации - это не доказательство уязвимости
        if (response.getStatusCode() == 422 || response.getStatusCode() == 400) {
            return null;
        }

        String responseBody = response.getBody().toLowerCase();
        int statusCode = response.getStatusCode();
        long responseTime = response.getResponseTime();

        switch (vulnerabilityType) {
            case SSTI:
                return detectSSTI(endpoint, parameter, payload, response, responseBody, statusCode, responseTime);
            case NOSQL_INJECTION:
                return detectNoSqlInjection(endpoint, parameter, payload, response, responseBody, statusCode);
            case PATH_TRAVERSAL:
                return detectPathTraversal(endpoint, parameter, payload, response, responseBody, statusCode);
            case COMMAND_INJECTION:
                return detectCommandInjection(endpoint, parameter, payload, response, responseBody, statusCode, responseTime);
            default:
                return null;
        }
    }

    private Vulnerability detectSSTI(ApiEndpoint endpoint, ApiParameter parameter,
                                     String payload, HttpResponse response,
                                     String responseBody, int statusCode, long responseTime) {
        // Проверяем, что сервер действительно обработал шаблон
        if (payload.contains("7*7") && responseBody.contains("49")) {
            // Убеждаемся, что 49 это результат вычисления, а не часть нормального ответа
            if (isSstiConfirmed(responseBody, response)) {
                return createVulnerability(endpoint, parameter, payload, response,
                        "Server-Side Template Injection",
                        "Сервер выполнил код шаблона: '" + payload + "'",
                        Severity.HIGH, Category.SSTI);
            }
        }

        // Проверяем ошибки обработки шаблонов
        for (String indicator : SSTI_INDICATORS) {
            if (responseBody.contains(indicator.toLowerCase()) &&
                    (statusCode == 500 || statusCode == 400)) {
                return createVulnerability(endpoint, parameter, payload, response,
                        "Server-Side Template Injection (Error-Based)",
                        "Обнаружена ошибка обработки шаблона при payload: '" + payload + "'",
                        Severity.HIGH, Category.SSTI);
            }
        }

        // Time-based SSTI
        if ((payload.contains("{{") || payload.contains("${")) && responseTime > 5000) {
            return createVulnerability(endpoint, parameter, payload, response,
                    "Time-Based Server-Side Template Injection",
                    "Значительное замедление ответа при payload: '" + payload + "'",
                    Severity.MEDIUM, Category.SSTI);
        }

        return null;
    }

    private boolean isSstiConfirmed(String responseBody, HttpResponse response) {
        try {
            // Проверяем, что 49 находится в контексте выполнения кода
            JSONObject json = new JSONObject(response.getBody());
            String jsonStr = json.toString().toLowerCase();
            return jsonStr.contains("\"49\"") || jsonStr.contains(":49") ||
                    jsonStr.contains("=49") || jsonStr.contains("49}");
        } catch (Exception e) {
            // Если ответ не JSON, ищем другие признаки
            return responseBody.contains("\"49\"") ||
                    responseBody.contains(":49") ||
                    (responseBody.contains("49") && (responseBody.contains("expression") ||
                            responseBody.contains("eval")));
        }
    }

    private Vulnerability detectNoSqlInjection(ApiEndpoint endpoint, ApiParameter parameter,
                                               String payload, HttpResponse response,
                                               String responseBody, int statusCode) {
        if (!payload.contains("$") && !payload.contains("where")) {
            return null;
        }

        for (String indicator : NOSQL_INDICATORS) {
            if (responseBody.contains(indicator) &&
                    (statusCode == 500 || statusCode == 400)) {
                return createVulnerability(endpoint, parameter, payload, response,
                        "NoSQL Injection",
                        "Обнаружена NoSQL инъекция через параметр: '" +
                                parameter.getName() + "' с payload: '" + payload + "'",
                        Severity.HIGH, Category.NOSQL_INJECTION);
            }
        }

        return null;
    }

    private Vulnerability detectCommandInjection(ApiEndpoint endpoint, ApiParameter parameter,
                                                 String payload, HttpResponse response,
                                                 String responseBody, int statusCode, long responseTime) {
        if (!payload.contains(";") && !payload.contains("|") &&
                !payload.contains("&") && !payload.contains("`")) {
            return null;
        }

        // Ищем признаки выполнения команды
        for (String indicator : CMD_INJECTION_INDICATORS) {
            if (responseBody.contains(indicator) &&
                    (statusCode == 200 || statusCode == 500)) {
                return createVulnerability(endpoint, parameter, payload, response,
                        "Command Injection",
                        "Обнаружены признаки выполнения команды при payload: '" + payload + "'",
                        Severity.CRITICAL, Category.COMMAND_INJECTION);
            }
        }

        // Time-based command injection
        if ((payload.contains("; sleep") || payload.contains("| sleep")) && responseTime > 5000) {
            return createVulnerability(endpoint, parameter, payload, response,
                    "Time-Based Command Injection",
                    "Значительное замедление ответа при payload: '" + payload + "'",
                    Severity.HIGH, Category.COMMAND_INJECTION);
        }

        return null;
    }

    private Vulnerability detectPathTraversal(ApiEndpoint endpoint, ApiParameter parameter,
                                              String payload, HttpResponse response,
                                              String responseBody, int statusCode) {
        if (!payload.contains("..") && !payload.contains("etc") && !payload.contains("passwd")) {
            return null;
        }

        if ((statusCode == 200 || statusCode == 500) &&
                (responseBody.contains("root:") || responseBody.contains("bin/bash") ||
                        responseBody.contains("etc/passwd"))) {
            return createVulnerability(endpoint, parameter, payload, response,
                    "Path Traversal",
                    "Обнаружены признаки чтения файловой системы при payload: '" + payload + "'",
                    Severity.HIGH, Category.PATH_TRAVERSAL);
        }

        return null;
    }

    private boolean isBusinessLogicAnomaly(String responseBody, String expectedBehavior, String payload) {
        // Проверяем, что негативные суммы были отклонены
        if (expectedBehavior.contains("rejected") && payload.startsWith("-")) {
            return responseBody.contains("error") ||
                    responseBody.contains("invalid") ||
                    responseBody.contains("negative") ||
                    responseBody.contains("not allowed");
        }

        // Проверяем, что слишком большие суммы были отклонены
        if (expectedBehavior.contains("excessive") && payload.contains("999999")) {
            return responseBody.contains("error") ||
                    responseBody.contains("exceed") ||
                    responseBody.contains("limit") ||
                    responseBody.contains("maximum");
        }

        return false;
    }

    public Vulnerability detectBusinessLogicBypass(ApiEndpoint endpoint, ApiParameter parameter,
                                                   String payload, HttpResponse response,
                                                   String expectedBehavior) {
        // Игнорируем ошибки валидации
        if (response.getStatusCode() == 422 || response.getStatusCode() == 400) {
            return null;
        }

        String responseBody = response.getBody().toLowerCase();
        int statusCode = response.getStatusCode();

        // Если операция прошла успешно, но не должна была
        if (statusCode == 200 || statusCode == 201) {
            boolean isAnomaly = isBusinessLogicAnomaly(responseBody, expectedBehavior, payload);

            // Если это аномалия - уязвимость
            if (!isAnomaly) {
                String description = "Бизнес-логика была обойдена: " +
                        expectedBehavior + " но операция завершилась успешно";

                return createVulnerability(endpoint, parameter, payload, response,
                        "Business Logic Bypass",
                        description,
                        Severity.MEDIUM, Category.BUSINESS_LOGIC_BYPASS);
            }
        }

        return null;
    }

    private Vulnerability createVulnerability(ApiEndpoint endpoint, ApiParameter parameter,
                                              String payload, HttpResponse response,
                                              String title, String description,
                                              Severity severity, Category category) {
        Vulnerability vuln = new Vulnerability();
        vuln.setTitle(title);
        vuln.setDescription(description);
        vuln.setSeverity(severity);
        vuln.setCategory(category);
        vuln.setEndpoint(endpoint.getPath());
        vuln.setMethod(endpoint.getMethod().name());
        vuln.setParameter(parameter.getName());
        vuln.setStatusCode(response.getStatusCode());
        vuln.setResponseTime(response.getResponseTime());

        // Добавляем доказательство
        StringBuilder evidence = new StringBuilder();
        evidence.append("=== ПОДТВЕРЖДЕННАЯ УЯЗВИМОСТЬ ===\n\n");
        evidence.append("Эндпоинт: ").append(endpoint.getMethod()).append(" ").append(endpoint.getPath()).append("\n");
        evidence.append("Параметр: ").append(parameter.getName()).append(" (").append(parameter.getLocation()).append(")\n");
        evidence.append("Payload: ").append(payload).append("\n\n");
        evidence.append("Ответ сервера:\n");
        evidence.append("Статус: ").append(response.getStatusCode()).append("\n");
        evidence.append("Время ответа: ").append(response.getResponseTime()).append("ms\n");
        evidence.append("Заголовки ответа:\n");

        for (Map.Entry<String, String> header : response.getHeaders().entrySet()) {
            evidence.append("  ").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
        }

        evidence.append("\nТело ответа (первые 500 символов):\n");
        String body = response.getBody();
        evidence.append(body.length() > 500 ? body.substring(0, 500) + "..." : body);

        vuln.setEvidence(evidence.toString());

        // Рекомендации по исправлению
        vuln.setRecommendations(generateRecommendations(category));

        return vuln;
    }

    private List<String> generateRecommendations(Category category) {
        List<String> recommendations = new ArrayList<>();

        switch (category) {
            case SSTI:
                recommendations.add("Используйте статические шаблоны вместо динамической обработки пользовательского ввода");
                recommendations.add("Применяйте sandbox для выполнения шаблонов");
                recommendations.add("Экранируйте пользовательский ввод перед передачей в шаблонизатор");
                recommendations.add("Используйте белые списки разрешенных функций шаблонизатора");
                break;
            case NOSQL_INJECTION:
                recommendations.add("Используйте ORM/ODM с защитой от инъекций (например, Mongoose с валидацией схемы)");
                recommendations.add("Санируйте пользовательский ввод перед использованием в запросах");
                recommendations.add("Применяйте принцип наименьших привилегий для БД");
                recommendations.add("Используйте параметризованные запросы вместо конкатенации строк");
                break;
            case COMMAND_INJECTION:
                recommendations.add("Избегайте выполнения shell-команд с пользовательским вводом");
                recommendations.add("Используйте API-методы вместо системных вызовов");
                recommendations.add("Применяйте белые списки разрешенных команд и параметров");
                recommendations.add("Экранируйте специальные символы в пользовательском вводе");
                break;
            case PATH_TRAVERSAL:
                recommendations.add("Валидируйте пути к файлам с использованием белых списков");
                recommendations.add("Используйте базовые директории (chroot) для ограничения доступа");
                recommendations.add("Нормализуйте пути перед обработкой");
                recommendations.add("Запрещайте использование специальных символов в путях");
                break;
            case BUSINESS_LOGIC_BYPASS:
                recommendations.add("Проверяйте бизнес-правила на стороне сервера, а не только на клиенте");
                recommendations.add("Валидируйте граничные значения для числовых параметров");
                recommendations.add("Реализуйте проверки логических ограничений перед выполнением операций");
                recommendations.add("Логируйте подозрительные операции для последующего анализа");
                break;
            default:
                recommendations.add("Проверьте корректность обработки пользовательского ввода");
                recommendations.add("Применяйте принцип наименьших привилегий");
                recommendations.add("Используйте параметризованные запросы");
                recommendations.add("Регулярно проводите тестирование на проникновение");
        }

        return recommendations;
    }
}