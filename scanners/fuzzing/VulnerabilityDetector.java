// scanners/fuzzing/VulnerabilityDetector.java
package scanners.fuzzing;

import core.Vulnerability;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class VulnerabilityDetector {

    private static final Set<String> SQL_ERRORS = Set.of(
            "sql syntax", "mysql_fetch", "ora-", "postgresql", "microsoft ole db",
            "syntax error", "violation", "pg_", "unclosed quotation", "odbc",
            "sqlstate", "pl/sql", "mysql", "postgres"
    );

    private static final Set<String> XSS_INDICATORS = Set.of(
            "script", "alert(", "onerror", "onload", "javascript:"
    );

    private static final Set<String> PATH_TRAVERSAL_INDICATORS = Set.of(
            "root:", "/etc/passwd", "windows/system32", "permission denied"
    );

    private static final Set<String> COMMAND_INJECTION_INDICATORS = Set.of(
            "bin/bash", "cmd.exe", "command not found"
    );

    // Кэш для предотвращения дублирования уязвимостей
    private final Map<String, Set<String>> detectedVulnerabilities = new ConcurrentHashMap<>();

    public Vulnerability analyzeResponse(ApiEndpoint endpoint, ApiParameter parameter,
                                         String payload, HttpResponse response,
                                         long responseTime) {

        String responseBody = response.getBody().toLowerCase();
        int statusCode = response.getStatusCode();

        // ИГНОРИРУЕМ ошибки, вызванные невалидным URL (ложные срабатывания)
        if (isUrlEncodingError(responseBody)) {
            return null;
        }

        // Создаем ключ для дедубликации
        String vulnKey = String.format("%s:%s:%s:%d",
                endpoint.getPath(), parameter.getName(),
                getVulnerabilityType(responseBody, statusCode, payload, responseTime),
                statusCode);

        // Проверяем, не находили ли мы уже эту уязвимость
        Set<String> endpointVulns = detectedVulnerabilities.computeIfAbsent(
                endpoint.getPath(), k -> ConcurrentHashMap.newKeySet());

        if (endpointVulns.contains(vulnKey)) {
            return null;
        }

        Vulnerability vulnerability = null;

        // Проверка SQL Injection (улучшенная логика)
        if (detectSqlInjection(responseBody, statusCode, payload, response)) {
            vulnerability = createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "SQL Injection in " + parameter.getName(),
                    "Обнаружена SQL инъекция через параметр " + parameter.getName(),
                    Vulnerability.Severity.HIGH,
                    Vulnerability.Category.SQL_INJECTION
            );
        }

        // Проверка XSS
        else if (detectXss(responseBody, payload, response)) {
            vulnerability = createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Cross-Site Scripting (XSS) in " + parameter.getName(),
                    "Обнаружена XSS уязвимость через параметр " + parameter.getName(),
                    Vulnerability.Severity.MEDIUM,
                    Vulnerability.Category.XSS
            );
        }

        // Проверка Path Traversal
        else if (detectPathTraversal(responseBody, statusCode, payload, response)) {
            vulnerability = createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Path Traversal in " + parameter.getName(),
                    "Обнаружена Path Traversal уязвимость через параметр " + parameter.getName(),
                    Vulnerability.Severity.HIGH,
                    Vulnerability.Category.PATH_TRAVERSAL
            );
        }

        // Проверка Command Injection
        else if (detectCommandInjection(responseBody, statusCode, payload, response)) {
            vulnerability = createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Command Injection in " + parameter.getName(),
                    "Обнаружена Command Injection уязвимость через параметр " + parameter.getName(),
                    Vulnerability.Severity.CRITICAL,
                    Vulnerability.Category.COMMAND_INJECTION
            );
        }

        // Проверка Time-based атак (улучшенная логика)
        else if (detectTimeBasedVulnerability(responseTime, payload, responseBody)) {
            vulnerability = createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Time-Based Blind Injection in " + parameter.getName(),
                    "Обнаружена возможная слепая уязвимость по времени ответа",
                    Vulnerability.Severity.MEDIUM,
                    Vulnerability.Category.SQL_INJECTION
            );
        }

        // Проверка Business Logic Bypass (улучшенная логика)
        else if (detectBusinessLogicBypass(statusCode, responseBody, payload, parameter, response)) {
            vulnerability = createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Business Logic Bypass in " + parameter.getName(),
                    "Обнаружен возможный обход бизнес-логики через параметр " + parameter.getName(),
                    Vulnerability.Severity.MEDIUM,
                    Vulnerability.Category.BUSINESS_LOGIC_BYPASS
            );
        }

        // Проверка нестандартных кодов ответа (ТОЛЬКО реальные подозрительные случаи)
        else if (detectSuspiciousStatusCode(statusCode, responseBody, payload, parameter)) {
            vulnerability = createVulnerability(
                    endpoint, parameter, payload, response, responseTime,
                    "Suspicious Response Code for " + parameter.getName(),
                    "Нестандартный код ответа при фаззинге параметра " + parameter.getName(),
                    Vulnerability.Severity.LOW,
                    Vulnerability.Category.FUZZING_GENERIC
            );
        }

        // Если нашли уязвимость - добавляем в кэш
        if (vulnerability != null) {
            endpointVulns.add(vulnKey);
        }

        return vulnerability;
    }

    // НОВЫЙ МЕТОД: Игнорируем ошибки кодирования URL (ложные срабатывания)
    private boolean isUrlEncodingError(String responseBody) {
        return responseBody.contains("illegal character in path") ||
                responseBody.contains("invalid character in path") ||
                responseBody.contains("malformed URL") ||
                responseBody.contains("url encoding") ||
                responseBody.contains("illegal character") && responseBody.contains("index");
    }

    private boolean detectSqlInjection(String responseBody, int statusCode, String payload, HttpResponse response) {
        // Игнорируем случаи, когда ошибка вызвана невалидным URL
        if (isUrlEncodingError(responseBody)) {
            return false;
        }

        boolean hasSqlError = false;
        for (String error : SQL_ERRORS) {
            if (responseBody.contains(error)) {
                hasSqlError = true;
                break;
            }
        }

        boolean hasSqlPatterns = payload.toLowerCase().contains("union") ||
                payload.toLowerCase().contains("select") ||
                payload.toLowerCase().contains("from information_schema") ||
                payload.toLowerCase().contains("sleep(") ||
                payload.toLowerCase().contains("waitfor");

        // Только если есть конкретные SQL ошибки И паттерны SQL в payload
        return hasSqlError && hasSqlPatterns;
    }

    private boolean detectXss(String responseBody, String payload, HttpResponse response) {
        // Проверка отражения payload'а без экранирования
        for (String indicator : XSS_INDICATORS) {
            if (payload.toLowerCase().contains(indicator) && responseBody.contains(indicator)) {
                // Дополнительная проверка: payload должен быть исполнен, а не просто отражен
                return isXssExecuted(responseBody, payload);
            }
        }
        return false;
    }

    private boolean isXssExecuted(String responseBody, String payload) {
        return responseBody.contains("<script") ||
                responseBody.contains("onerror") ||
                responseBody.contains("onload") ||
                responseBody.contains("javascript:");
    }

    private boolean detectPathTraversal(String responseBody, int statusCode, String payload, HttpResponse response) {
        if (!payload.contains("..") && !payload.contains("etc") && !payload.contains("windows")) {
            return false;
        }

        for (String indicator : PATH_TRAVERSAL_INDICATORS) {
            if (responseBody.contains(indicator)) {
                return true;
            }
        }

        return false;
    }

    private boolean detectCommandInjection(String responseBody, int statusCode, String payload, HttpResponse response) {
        if (!payload.contains(";") && !payload.contains("|") && !payload.contains("&") && !payload.contains("`")) {
            return false;
        }

        for (String indicator : COMMAND_INJECTION_INDICATORS) {
            if (responseBody.contains(indicator)) {
                return true;
            }
        }

        return false;
    }

    private boolean detectTimeBasedVulnerability(long responseTime, String payload, String responseBody) {
        boolean hasTimePattern = payload.toLowerCase().contains("sleep") ||
                payload.toLowerCase().contains("waitfor") ||
                payload.toLowerCase().contains("benchmark");

        return responseTime > 5000 && hasTimePattern && !responseBody.contains("timeout");
    }

    private boolean detectBusinessLogicBypass(int statusCode, String responseBody, String payload,
                                              ApiParameter parameter, HttpResponse response) {
        String paramName = parameter.getName().toLowerCase();
        String paramType = parameter.getType().toLowerCase();

        // Проверяем только для числовых параметров
        if (!paramType.contains("number") && !paramType.contains("integer") &&
                !paramName.contains("amount") && !paramName.contains("balance") && !paramName.contains("limit")) {
            return false;
        }

        // Отрицательные суммы, которые прошли
        if (payload.contains("-") && statusCode == 200) {
            return !responseBody.contains("error") && !responseBody.contains("invalid") &&
                    responseBody.length() > 50; // Должен быть содержательный ответ
        }

        // Очень большие числа, которые прошли
        if ((payload.contains("999999999") || payload.contains("1e308")) && statusCode == 200) {
            return !responseBody.contains("error") && !responseBody.contains("exceed") &&
                    !responseBody.contains("limit") && responseBody.length() > 50;
        }

        return false;
    }

    private boolean detectSuspiciousStatusCode(int statusCode, String responseBody, String payload, ApiParameter parameter) {
        // Только конкретные подозрительные коды с определенными условиями
        if (statusCode == 403) {
            return responseBody.contains("forbidden") && !isUrlEncodingError(responseBody);
        }
        if (statusCode == 500) {
            // 500 код подозрителен только если нет ошибок кодирования URL и есть SQL/командные инъекции
            return !isUrlEncodingError(responseBody) &&
                    (payload.contains("'") || payload.contains(";") || payload.contains("|"));
        }
        return false;
    }

    private String getVulnerabilityType(String responseBody, int statusCode, String payload, long responseTime) {
        if (detectSqlInjection(responseBody, statusCode, payload, null)) return "SQLI";
        if (detectXss(responseBody, payload, null)) return "XSS";
        if (detectPathTraversal(responseBody, statusCode, payload, null)) return "PATH_TRAVERSAL";
        if (detectCommandInjection(responseBody, statusCode, payload, null)) return "COMMAND_INJECTION";
        if (detectTimeBasedVulnerability(responseTime, payload, responseBody)) return "TIME_BASED";
        if (detectSuspiciousStatusCode(statusCode, responseBody, payload, null)) return "SUSPICIOUS_STATUS";
        return "UNKNOWN";
    }

    private Vulnerability createVulnerability(ApiEndpoint endpoint, ApiParameter parameter,
                                              String payload, HttpResponse response,
                                              long responseTime, String title, String description,
                                              Vulnerability.Severity severity, Vulnerability.Category category) {

        Vulnerability vuln = new Vulnerability();
        vuln.setTitle(title);
        vuln.setDescription(description);
        vuln.setSeverity(severity);
        vuln.setCategory(category);
        vuln.setEndpoint(endpoint.getPath());
        vuln.setMethod(endpoint.getMethod().name());
        vuln.setParameter(parameter.getName());
        vuln.setStatusCode(response.getStatusCode());
        vuln.setResponseTime(responseTime);

        // УЛУЧШЕННОЕ доказательство с большей информацией
        String evidence = buildDetailedEvidence(payload, response, responseTime, parameter);
        vuln.setEvidence(evidence);

        // Добавление рекомендаций
        vuln.setRecommendations(generateRecommendations(category));

        return vuln;
    }

    // НОВЫЙ МЕТОД: Детализированное доказательство
    private String buildDetailedEvidence(String payload, HttpResponse response, long responseTime, ApiParameter parameter) {
        StringBuilder evidence = new StringBuilder();

        evidence.append("=== ДЕТАЛЬНОЕ ДОКАЗАТЕЛЬСТВО ===\n\n");
        evidence.append("ПАРАМЕТР: ").append(parameter.getName()).append("\n");
        evidence.append("ТИП: ").append(parameter.getType()).append("\n");
        evidence.append("РАСПОЛОЖЕНИЕ: ").append(parameter.getLocation()).append("\n");
        evidence.append("ОБЯЗАТЕЛЬНЫЙ: ").append(parameter.isRequired()).append("\n\n");

        evidence.append("PAYLOAD: ").append(payload).append("\n\n");

        evidence.append("ОТВЕТ СЕРВЕРА:\n");
        evidence.append("Status Code: ").append(response.getStatusCode()).append("\n");
        evidence.append("Response Time: ").append(responseTime).append("ms\n");
        evidence.append("Response Size: ").append(response.getBody().length()).append(" bytes\n\n");

        evidence.append("ЗАГОЛОВКИ ОТВЕТА:\n");
        for (Map.Entry<String, String> header : response.getHeaders().entrySet()) {
            evidence.append("  ").append(header.getKey()).append(": ").append(header.getValue()).append("\n");
        }
        evidence.append("\n");

        evidence.append("ТЕЛО ОТВЕТА:\n");
        String body = response.getBody();
        if (body.length() > 1000) {
            evidence.append(body.substring(0, 500)).append("\n\n... [сокращено] ...\n\n")
                    .append(body.substring(body.length() - 500));
        } else {
            evidence.append(body);
        }

        return evidence.toString();
    }

    private List<String> generateRecommendations(Vulnerability.Category category) {
        List<String> recommendations = new ArrayList<>();

        switch (category) {
            case SQL_INJECTION:
                recommendations.add("Используйте prepared statements и parameterized queries");
                recommendations.add("Валидируйте и санируйте все пользовательские входные данные");
                recommendations.add("Применяйте принцип наименьших привилегий для БД");
                recommendations.add("Используйте ORM с защитой от SQL инъекций");
                break;

            case XSS:
                recommendations.add("Экранируйте все пользовательские данные при выводе в HTML");
                recommendations.add("Используйте Content Security Policy (CSP)");
                recommendations.add("Установите заголовок X-XSS-Protection");
                recommendations.add("Валидируйте входные данные на стороне сервера");
                break;

            case PATH_TRAVERSAL:
                recommendations.add("Валидируйте пути к файлам с помощью whitelist");
                recommendations.add("Используйте базовые директории (chroot)");
                recommendations.add("Запретите использование специальных символов в путях");
                recommendations.add("Нормализуйте пути перед обработкой");
                break;

            case COMMAND_INJECTION:
                recommendations.add("Избегайте выполнения shell команд с пользовательскими данными");
                recommendations.add("Используйте whitelist разрешенных команд и параметров");
                recommendations.add("Экранируйте специальные символы в командах");
                recommendations.add("Используйте API вместо shell команд");
                break;

            case BUSINESS_LOGIC_BYPASS:
                recommendations.add("Реализуйте строгую валидацию бизнес-правил");
                recommendations.add("Проверяйте граничные значения для числовых параметров");
                recommendations.add("Внедрите лимиты и квоты для операций");
                recommendations.add("Логируйте подозрительные операции");
                break;

            default:
                recommendations.add("Проведите дополнительный анализ уязвимости");
                recommendations.add("Обновите зависимости и фреймворки");
                recommendations.add("Внедрите регулярное тестирование безопасности");
                recommendations.add("Рассмотрите использование WAF для дополнительной защиты");
        }

        return recommendations;
    }

    // Метод для очистки кэша между сканированиями
    public void clearCache() {
        detectedVulnerabilities.clear();
    }
}